<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wheelie Bin Scale Visualiser + Rain Calculator</title>
    <style>
        /* --- LAYOUT STRUCTURE --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #87CEEB; 
            font-family: 'Segoe UI', -apple-system, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh; 
            width: 100vw;
        }
        
        #canvas-wrapper {
            position: relative;
            width: 100%;
            flex-grow: 1; 
            min-height: 0; 
            overflow: hidden;
            z-index: 1;
            background-color: #87CEEB; 
        }

        canvas { 
            display: block; 
            width: 100% !important;
            height: 100% !important;
            outline: none;
        }
        
        /* --- UI STYLING --- */
        #ui-container {
            position: absolute; 
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            padding: 20px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
            width: 280px;
            user-select: none;
            color: #1a472a;
            transition: all 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        h2 {
            margin: 0 0 10px 0;
            font-size: 18px;
            font-weight: 800;
            text-transform: lowercase;
            letter-spacing: -0.5px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
            padding-bottom: 10px;
            text-align: center;
        }

        .display-group { text-align: center; margin-bottom: 15px; }
        
        .big-number {
            font-size: 28px;
            font-weight: 800;
            display: block;
            color: #1a472a;
            line-height: 1.1;
        }

        .sub-text {
            font-size: 14px;
            color: #666;
            font-weight: 500;
            margin-top: 2px;
            display: block;
        }

        label { 
            font-size: 11px; 
            font-weight: 700; 
            color: #888; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            display: block;
            margin-top: 12px;
            margin-bottom: 4px;
        }

        select {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-family: inherit;
            font-weight: 600;
            color: #333;
            box-sizing: border-box;
            font-size: 14px;
            outline: none;
            margin-bottom: 5px;
            background-color: white;
            cursor: pointer;
        }

        input[type=range] { 
            width: 100%; 
            accent-color: #2E8B57; 
            cursor: pointer; 
            height: 6px;
            margin-bottom: 5px;
        }

        .input-wrapper { position: relative; margin-top: 5px; margin-bottom: 8px; }

        input[type=number] {
            width: 100%;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-family: inherit;
            font-weight: 600;
            color: #333;
            box-sizing: border-box;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        input[type=number]:focus { border-color: #2E8B57; }

        .unit {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
        }

        /* --- TOGGLES --- */
        #mobile-toggle {
            display: block;
            width: 100%;
            text-align: center;
            margin-top: 15px;
            cursor: pointer;
            color: #2E8B57;
            font-size: 12px;
            font-weight: 700;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: opacity 0.2s;
            padding: 5px 0;
        }
        
        #mobile-toggle:hover { opacity: 1; background: rgba(0,0,0,0.02); border-radius: 4px; }
        
        #rendering-controls {
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            max-height: 300px; 
            opacity: 1;
        }
        
        #rendering-controls.collapsed {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        .toggle-group {
            background: rgba(0,0,0,0.03);
            border-radius: 8px;
            padding: 5px 10px;
            margin-top: 5px;
        }
        
        .main-toggle {
            background: #e8f5e9;
            border: 1px solid #c8e6c9;
            margin-top: 15px;
        }

        .toggle-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }
        .toggle-wrapper:last-child { border-bottom: none; }

        .toggle-text { font-size: 12px; font-weight: 700; color: #1a472a; }

        .switch {
            position: relative;
            display: inline-block;
            width: 34px;
            height: 18px;
            margin: 0;
        }
        .switch input { opacity: 0; width: 0; height: 0; }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 12px; width: 12px;
            left: 3px; bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: #2E8B57; }
        input:checked + .slider:before { transform: translateX(16px); }

        .footer-note {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(0,0,0,0.1);
            font-size: 10px;
            color: #555;
            text-align: center;
            font-style: italic;
            opacity: 0.8;
            line-height: 1.3;
        }
        
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 200;
        }
        #controls-hint.visible { opacity: 1; }

        /* Helpers for showing/hiding inputs */
        .hidden { display: none; }

        /* --- MOBILE STACKED LAYOUT --- */
        @media (max-width: 600px) {
            #ui-container {
                position: relative; 
                top: auto; left: auto; right: auto; bottom: auto;
                width: 100%; 
                min-width: 0;
                border-radius: 0; 
                padding: 15px 24px 20px 24px; 
                box-sizing: border-box;
                border: none;
                border-top: 1px solid rgba(0,0,0,0.1);
                box-shadow: 0 -5px 20px rgba(0,0,0,0.05);
                flex-shrink: 0; 
                z-index: 10;
                background: #fff;
            }
            
            h2 { font-size: 15px; margin-bottom: 8px; }
            .big-number { font-size: 20px; }
            .sub-text { font-size: 12px; }
            .display-group { 
                display: flex; align-items: baseline; justify-content: center; 
                gap: 8px; margin-bottom: 12px; 
            }
            label { font-size: 10px; margin-top: 10px; }
            input[type=range] { margin-top: 5px; }
            #mobile-toggle { margin-top: 10px; font-size: 11px; }
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="canvas-wrapper"></div>
<div id="controls-hint">Use W, A, S, D to Move</div>

<div id="ui-container">
    <h2>Wheelie Bin Flow</h2>
    
    <div class="display-group">
        <span id="binDisplay" class="big-number">10 bins</span>
        <span id="literDisplay" class="sub-text">(1,200 L/s)</span>
    </div>

    <label>Calculation Mode</label>
    <select id="modeSelect">
        <option value="direct">Direct Flow (L/s)</option>
        <option value="rain">Rainfall Event (mm/hr)</option>
    </select>

    <div id="directControls">
        <label>Count (Logarithmic)</label>
        <input type="range" id="binSlider" min="0" max="1000" value="10">

        <label>Flow Rate</label>
        <div class="input-wrapper">
            <input type="number" id="literInput" value="1200">
            <span class="unit">L/s</span>
        </div>
    </div>

    <div id="rainControls" class="hidden">
        <label>Rainfall Intensity</label>
        <div class="input-wrapper">
            <input type="number" id="rainMmInput" value="50">
            <span class="unit">mm/hr</span>
        </div>

        <label>Catchment Area</label>
        <div class="input-wrapper">
            <input type="number" id="areaInput" value="5000">
            <span class="unit">mÂ²</span>
        </div>
        <div class="footer-note" style="margin-top:5px; border:none;">
            1 mm of rain on 1 mÂ² = 1 Liter.
        </div>
    </div>
    
    <div class="toggle-group main-toggle">
        <div class="toggle-wrapper">
            <span class="toggle-text">ðŸš¶ Walk Mode</span>
            <label class="switch">
                <input type="checkbox" id="walkToggle">
                <span class="slider round"></span>
            </label>
        </div>
    </div>

    <div id="mobile-toggle">ðŸ”½ Performance Options</div>

    <div id="rendering-controls" class="collapsed">
        <div class="toggle-group">
            <div class="toggle-wrapper">
                <span class="toggle-text">Optimised Rendering</span>
                <label class="switch">
                    <input type="checkbox" id="shellToggle">
                    <span class="slider round"></span>
                </label>
            </div>
            
            <div class="toggle-wrapper">
                <span class="toggle-text">Solid Core (Infill)</span>
                <label class="switch">
                    <input type="checkbox" id="infillToggle">
                    <span class="slider round"></span>
                </label>
            </div>
        </div>

        <div class="footer-note">
            Optimised mode draws outer shell only.<br>
            Infill draws solid mass inside pile.
        </div>
    </div>
</div>

<script>
    // --- 1. CONFIGURATION ---
    const COLORS = {
        grass: 0x5cb85c,
        grassBlade: 0x4da04d,
        binBody: 0x1a472a, 
        lids: [0xd9534f, 0xf0ad4e, 0x3366cc], 
        wheels: 0x222222,
        sky: 0x87CEEB,
        wood: 0x8B5A2B,
        treeTrunk: 0xE0E0E0,
        treeLeaves: 0x2E8B57,
        crownGlass: 0xAACCFF,
        bananaYellow: 0xFFE135, 
        bananaTip: 0x4A3328,
        concrete: 0x999999,
        darkVoid: 0x0f2b19,
        player: 0xff5500
    };

    const BIN_SPACING = 0.9; 
    const BIN_HEIGHT = 1.1;
    const GRID_RADIUS = 70; 

    // --- 2. SCENE SETUP ---
    const canvasWrapper = document.getElementById('canvas-wrapper');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.sky);
    scene.fog = new THREE.Fog(COLORS.sky, 100, 600);

    const camera = new THREE.PerspectiveCamera(45, canvasWrapper.clientWidth / canvasWrapper.clientHeight, 1, 15000);
    camera.position.set(5, 5, 5); 
    
    const targetCameraPos = new THREE.Vector3(5, 5, 5);
    const targetLookAt = new THREE.Vector3(0, 0.5, 0);
    let shouldAutoPan = false;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvasWrapper.clientWidth, canvasWrapper.clientHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    canvasWrapper.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.bias = -0.0005;
    scene.add(dirLight);

    const d = 80;
    dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;

    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(5000, 5000),
        new THREE.MeshToonMaterial({ color: COLORS.grass })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // --- 3. ENVIRONMENT & COLLISION SYSTEM ---
    const obstacles = [];
    const binChunks = new Map(); // Spatial Hash for bins
    const CHUNK_SIZE = 2.0;

    function registerObstacle(x, z, radius) {
        obstacles.push({ x, z, r: radius, rSq: radius * radius });
    }

    function addToBinChunk(x, z) {
        const cx = Math.floor(x / CHUNK_SIZE);
        const cz = Math.floor(z / CHUNK_SIZE);
        const key = `${cx},${cz}`;
        if (!binChunks.has(key)) binChunks.set(key, []);
        binChunks.get(key).push({x, z, r: 0.4}); // Bin radius approx 0.4
    }

    let validSlots = []; 

    function createEnvironment() {
        const envGroup = new THREE.Group();
        
        // --- Tree ---
        const treeGroup = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.6, 3, 7), new THREE.MeshToonMaterial({ color: COLORS.treeTrunk }));
        trunk.position.y = 1.5; trunk.castShadow = true; trunk.receiveShadow = true; treeGroup.add(trunk);
        const leafGeo = new THREE.IcosahedronGeometry(1.5, 0); const leafMat = new THREE.MeshToonMaterial({ color: COLORS.treeLeaves });
        [[0,3.5,0], [1,3,1], [-1,3.2,-0.5], [0.5,4,-1]].forEach(p => {
            const l = new THREE.Mesh(leafGeo, leafMat); l.position.set(...p); l.castShadow = true; l.scale.setScalar(0.8 + Math.random()*0.4); treeGroup.add(l);
        });
        treeGroup.position.set(-8, 0, -5); envGroup.add(treeGroup); 
        registerObstacle(-8, -5, 1.2); // Trunk collision only

        // --- Bench ---
        const benchGroup = new THREE.Group();
        const woodMat = new THREE.MeshToonMaterial({ color: COLORS.wood });
        const seat = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.45), woodMat); seat.position.y = 0.45; seat.castShadow = true; benchGroup.add(seat);
        const back = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.05), woodMat); back.position.set(0, 0.85, -0.2); back.castShadow = true; benchGroup.add(back);
        const legGeo = new THREE.BoxGeometry(0.1, 0.45, 0.4);
        const l1 = new THREE.Mesh(legGeo, woodMat); l1.position.set(-0.6, 0.225, 0); benchGroup.add(l1);
        const l2 = new THREE.Mesh(legGeo, woodMat); l2.position.set(0.6, 0.225, 0); benchGroup.add(l2);
        benchGroup.position.set(-3, 0, -2); benchGroup.rotation.y = 0.2; envGroup.add(benchGroup); 
        registerObstacle(-3, -2, 1.0);

        scene.add(envGroup);
    }
    
    function createLandmarks() {
        const landmarkGroup = new THREE.Group();
        // BIG BANANA
        const bananaGroup = new THREE.Group();
        const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(-6, 3.8, 0), new THREE.Vector3(-3, 1.2, 0), new THREE.Vector3(0, 0.6, 0), new THREE.Vector3(3, 1.2, 0), new THREE.Vector3(6, 3.8, 0)]);
        const segments = 48; const radialSegments = 16;
        const tubeGeo = new THREE.TubeGeometry(curve, segments, 1, radialSegments, false);
        const pos = tubeGeo.attributes.position;
        for(let i=0; i <= segments; i++) {
            const u = i / segments; const scale = 0.25 + Math.sin(u * Math.PI) * 1.15; const center = curve.getPointAt(u);
            for(let j=0; j <= radialSegments; j++) {
                const idx = i * (radialSegments + 1) + j; if(idx >= pos.count) continue;
                const px = pos.getX(idx); const py = pos.getY(idx); const pz = pos.getZ(idx);
                pos.setXYZ(idx, center.x + (px - center.x) * scale, center.y + (py - center.y) * scale, center.z + (pz - center.z) * scale);
            }
        }
        tubeGeo.computeVertexNormals();
        const bananaBody = new THREE.Mesh(tubeGeo, new THREE.MeshToonMaterial({ color: COLORS.bananaYellow, emissive: 0x222200 })); bananaBody.castShadow = true; bananaGroup.add(bananaBody);
        const tipMat = new THREE.MeshToonMaterial({ color: COLORS.bananaTip }); const tipGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const tip1 = new THREE.Mesh(tipGeo, tipMat); tip1.position.set(-6, 3.8, 0); bananaGroup.add(tip1);
        const tip2 = new THREE.Mesh(tipGeo, tipMat); tip2.position.set(6, 3.8, 0); bananaGroup.add(tip2);
        const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 3.7, 8); const pillarMat = new THREE.MeshToonMaterial({ color: COLORS.concrete });
        const leg1 = new THREE.Mesh(pillarGeo, pillarMat); leg1.position.set(-3, -0.65, 0); bananaGroup.add(leg1);
        const leg2 = new THREE.Mesh(pillarGeo, pillarMat); leg2.position.set(3, -0.65, 0); bananaGroup.add(leg2);
        bananaGroup.position.set(-35, 2.5, 5); bananaGroup.rotation.set(0, Math.PI / 6, 0); landmarkGroup.add(bananaGroup); 
        
        // Banana legs collision
        const bananaX = -35; const bananaZ = 5;
        // Approximation
        registerObstacle(bananaX - 1.5, bananaZ + 1, 1.5); 
        registerObstacle(bananaX + 1.5, bananaZ - 1, 1.5);

        // CROWN
        const crownHeight = 271.3; const crownGeo = new THREE.CylinderGeometry(1, 1, crownHeight, 60, 80, true);
        const cPos = crownGeo.attributes.position;
        for(let i=0; i < cPos.count; i++) {
            let x = cPos.getX(i); let y = cPos.getY(i); let z = cPos.getZ(i);
            const normY = (y + crownHeight/2) / crownHeight;
            let taper = (normY < 0.3) ? 1.0 + (normY/0.3)*0.2 : 1.2 - ((normY-0.3)/0.7)*0.8;
            const angle = Math.atan2(z, x); const petal = 1 + 0.2 * Math.sin(3 * angle);
            const twistAngle = normY * (Math.PI / 3); const cosT = Math.cos(twistAngle); const sinT = Math.sin(twistAngle);
            let currentR = 25 * taper * petal;
            let nx = Math.cos(angle) * currentR; let nz = Math.sin(angle) * currentR;
            cPos.setXYZ(i, nx * cosT - nz * sinT, y + crownHeight/2, nx * sinT + nz * cosT);
        }
        crownGeo.computeVertexNormals();
        const crown = new THREE.Mesh(crownGeo, new THREE.MeshStandardMaterial({ color: COLORS.crownGlass, metalness: 0.6, roughness: 0.2, transparent: true, opacity: 0.85 }));
        crown.castShadow = true; crown.position.set(0, 0, -80); landmarkGroup.add(crown); registerObstacle(0, -80, 30);
        for(let h=10; h<271; h+=15) {
            const normY = h/271; let taper = (normY < 0.3) ? 1.0 + (normY/0.3)*0.2 : 1.2 - ((normY-0.3)/0.7)*0.8;
            const ring = new THREE.Mesh(new THREE.TorusGeometry(25 * taper, 0.5, 4, 60), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.3}));
            ring.rotation.x = Math.PI/2; ring.rotation.z = normY * (Math.PI / 3); ring.position.set(0, h, -80); landmarkGroup.add(ring);
        }
        scene.add(landmarkGroup);
    }

    function generateSlots() {
        validSlots = [];
        const steps = Math.ceil(GRID_RADIUS / BIN_SPACING);
        const OBSTACLE_WALL_THICKNESS = 3.5; 

        for(let x = -steps; x <= steps; x++) {
            for(let z = -steps; z <= steps; z++) {
                const wx = x * BIN_SPACING; const wz = z * BIN_SPACING; const distSq = wx*wx + wz*wz;
                if(distSq > GRID_RADIUS * GRID_RADIUS) continue;
                let isBlocked = false; let isBoundary = false;
                for(let ob of obstacles) {
                    const dx = wx - ob.x; const dz = wz - ob.z; const dSq = dx*dx + dz*dz;
                    if(dSq < ob.rSq) { isBlocked = true; break; }
                    if (Math.sqrt(dSq) < ob.r + OBSTACLE_WALL_THICKNESS) { isBoundary = true; }
                }
                if(!isBlocked) { validSlots.push({ x: wx, z: wz, d: distSq, isBoundary: isBoundary }); }
            }
        }
        validSlots.sort((a, b) => a.d - b.d);
    }

    createEnvironment(); createLandmarks(); generateSlots();

    function createGrass() {
        const count = 5000;
        const mesh = new THREE.InstancedMesh(new THREE.ConeGeometry(0.05, 0.3, 3).translate(0, 0.15, 0), new THREE.MeshToonMaterial({ color: COLORS.grassBlade }), count);
        const dummy = new THREE.Object3D();
        for(let i=0; i<count; i++) {
            dummy.position.set((Math.random()-0.5)*250, 0, (Math.random()-0.5)*250);
            dummy.rotation.y = Math.random() * Math.PI; dummy.scale.setScalar(0.5 + Math.random()); dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
        }
        mesh.receiveShadow = true; scene.add(mesh);
    }
    createGrass();

    // --- 4. INSTANCED BINS ---
    const boxBodyGeo = new THREE.BoxGeometry(0.58, 0.9, 0.6); boxBodyGeo.translate(0, 0.45, 0);
    const boxLidGeo = new THREE.BoxGeometry(0.62, 0.05, 0.65); boxLidGeo.translate(0, 0.925, 0);
    const boxWheelGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.08, 8); boxWheelGeo.rotateZ(Math.PI/2);
    const bodyMat = new THREE.MeshToonMaterial({ color: COLORS.binBody });
    const lidMat = new THREE.MeshToonMaterial({ color: 0xffffff });
    const wheelMat = new THREE.MeshToonMaterial({ color: COLORS.wheels });

    let imBody, imLid, imWheelLeft, imWheelRight;
    let isHighPoly = false;
    let instanceData = []; 
    let coreMesh = null; // Variable for the void blocker

    function disposeInstancedMeshes() {
        if(imBody) { scene.remove(imBody); imBody.dispose(); imBody = null; }
        if(imLid) { scene.remove(imLid); imLid.dispose(); imLid = null; }
        if(imWheelLeft) { scene.remove(imWheelLeft); imWheelLeft.dispose(); imWheelLeft = null; }
        if(imWheelRight) { scene.remove(imWheelRight); imWheelRight.dispose(); imWheelRight = null; }
    }

    function setupInstancedMeshes(count, highDetail) {
        disposeInstancedMeshes();
        isHighPoly = highDetail;
        imBody = new THREE.InstancedMesh(boxBodyGeo, bodyMat, count); imBody.castShadow = true; imBody.receiveShadow = true; scene.add(imBody);
        imLid = new THREE.InstancedMesh(boxLidGeo, lidMat, count); imLid.castShadow = true; scene.add(imLid);
        if(highDetail) {
            imWheelLeft = new THREE.InstancedMesh(boxWheelGeo, wheelMat, count); imWheelRight = new THREE.InstancedMesh(boxWheelGeo, wheelMat, count);
            scene.add(imWheelLeft); scene.add(imWheelRight);
        }
    }

    const dummy = new THREE.Object3D(); const color = new THREE.Color();

    function updateCore(radius, height) {
        if (coreMesh) {
            scene.remove(coreMesh);
            coreMesh.geometry.dispose();
            coreMesh = null;
        }
        const maxR = Math.max(0.1, radius - 1.5);
        const edgeObstacles = [];
        const insideObstacles = [];
        obstacles.forEach(ob => {
            const dist = Math.sqrt(ob.x * ob.x + ob.z * ob.z);
            if (dist + ob.r > maxR && dist - ob.r < maxR) { edgeObstacles.push(ob); } 
            else if (dist + ob.r <= maxR) { insideObstacles.push(ob); }
        });

        const shape = new THREE.Shape();
        const resolution = 180; 
        const points = [];
        for (let i = 0; i <= resolution; i++) {
            const theta = (i / resolution) * Math.PI * 2;
            const dirX = Math.cos(theta); const dirZ = Math.sin(theta); 
            let currentDist = maxR;
            edgeObstacles.forEach(ob => {
                const cx = ob.x; const cy = -ob.z; const rEff = ob.r + 2.0; 
                const B = -2 * (dirX * cx + dirZ * cy);
                const C = (cx * cx + cy * cy) - (rEff * rEff);
                const delta = B * B - 4 * C;
                if (delta >= 0) {
                    const t1 = (-B - Math.sqrt(delta)) / 2;
                    if (t1 > 0 && t1 < currentDist) currentDist = t1;
                }
            });
            points.push(new THREE.Vector2(dirX * currentDist, dirZ * currentDist)); 
        }
        shape.setFromPoints(points);
        insideObstacles.forEach(ob => {
            const hole = new THREE.Path();
            hole.absarc(ob.x, -ob.z, ob.r + 2.0, 0, Math.PI * 2, true); 
            shape.holes.push(hole);
        });

        const geometry = new THREE.ExtrudeGeometry(shape, {
            depth: height,
            bevelEnabled: false,
            curveSegments: 16
        });
        coreMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: COLORS.darkVoid }));
        coreMesh.rotation.x = -Math.PI / 2; 
        scene.add(coreMesh);
    }

    function populateScene(targetCount, doAutoFit = true) {
        // Clear old spatial hash
        binChunks.clear();

        const shellToggle = document.getElementById('shellToggle');
        const infillToggle = document.getElementById('infillToggle');
        const useShellMode = shellToggle.checked;
        const useInfill = infillToggle.checked;
        const highDetail = targetCount < 5000;
        
        const allocationCount = useShellMode ? 500000 : targetCount;
        setupInstancedMeshes(allocationCount, highDetail);

        instanceData = []; let visualIndex = 0;
        const slotsPerLayer = validSlots.length;
        const totalLayers = Math.ceil(targetCount / slotsPerLayer);
        const SOLID_TOP_LAYERS = 4; const WALL_PERCENTAGE = 0.12; 

        const lastLayerIndex = totalLayers - 1;
        const radiusIndex = Math.min(targetCount, slotsPerLayer) - 1;
        const currentRadius = (targetCount < slotsPerLayer) ? Math.sqrt(validSlots[radiusIndex].d) : GRID_RADIUS;
        const currentHeight = (lastLayerIndex + 1) * BIN_HEIGHT;

        if (useInfill && currentRadius > 2.5) {
            const coreH = Math.max(0.1, (totalLayers - SOLID_TOP_LAYERS) * BIN_HEIGHT);
            updateCore(currentRadius, coreH);
        } else {
             if (coreMesh) { scene.remove(coreMesh); coreMesh.geometry.dispose(); coreMesh = null; }
        }

        if (useShellMode) {
            const wallThicknessCount = Math.floor(slotsPerLayer * WALL_PERCENTAGE);
            const wallStartIndex = Math.max(0, slotsPerLayer - wallThicknessCount);
            for(let l = 0; l < totalLayers; l++) {
                const isSolidLayer = (l >= totalLayers - SOLID_TOP_LAYERS);
                let end = slotsPerLayer;
                if (l === totalLayers - 1) { const remainder = targetCount % slotsPerLayer; if(remainder !== 0) end = remainder; }
                const wy = l * BIN_HEIGHT;
                
                // Only register physics for bottom layer bins
                const registerPhysics = (l === 0);

                for(let s = 0; s < end; s++) {
                    const slot = validSlots[s]; const isOuterRing = s >= wallStartIndex;
                    if (isSolidLayer || isOuterRing || slot.isBoundary) {
                        const rotY = (Math.random() - 0.5) * 0.2; const colorIndex = (s + l) % 3;
                        addInstance(visualIndex, slot.x, wy, slot.z, rotY, colorIndex, highDetail);
                        
                        if(registerPhysics) addToBinChunk(slot.x, slot.z);

                        visualIndex++; if(visualIndex >= allocationCount) break;
                    }
                }
                if(visualIndex >= allocationCount) break;
            }
            imBody.count = visualIndex; imLid.count = visualIndex;
            if(imWheelLeft) imWheelLeft.count = visualIndex; if(imWheelRight) imWheelRight.count = visualIndex;
        } else {
            let placed = 0; let layerIndex = 0; let slotIndex = 0;
            while(placed < targetCount) {
                if (slotIndex >= slotsPerLayer) { slotIndex = 0; layerIndex++; }
                const slot = validSlots[slotIndex]; const wy = layerIndex * BIN_HEIGHT;
                const rotY = (Math.random() - 0.5) * 0.2; const colorIndex = (slotIndex + layerIndex) % 3;
                addInstance(placed, slot.x, wy, slot.z, rotY, colorIndex, highDetail);
                
                // Only bottom layer for physics
                if (layerIndex === 0) addToBinChunk(slot.x, slot.z);

                placed++; slotIndex++;
            }
        }

        imBody.instanceMatrix.needsUpdate = true; imLid.instanceMatrix.needsUpdate = true;
        if(imLid.instanceColor) imLid.instanceColor.needsUpdate = true;
        if(highDetail) { imWheelLeft.instanceMatrix.needsUpdate = true; imWheelRight.instanceMatrix.needsUpdate = true; }

        const maxDim = Math.max(currentRadius * 2.2, currentHeight * 1.2, 280); 
        const camSize = Math.max(80, maxDim * 0.6);
        dirLight.shadow.camera.left = -camSize; dirLight.shadow.camera.right = camSize;
        dirLight.shadow.camera.top = camSize; dirLight.shadow.camera.bottom = -camSize;
        dirLight.shadow.camera.updateProjectionMatrix();

        if (doAutoFit && !playerModeActive) {
            const pileCenterY = currentHeight / 2; const pileCenter = new THREE.Vector3(0, pileCenterY, 0); targetLookAt.copy(pileCenter);
            const boundSize = Math.max(currentRadius * 1.5, currentHeight); const dist = 8 + (boundSize * 1.8);
            const offset = new THREE.Vector3(1, 0.8, 1).normalize().multiplyScalar(dist);
            targetCameraPos.copy(pileCenter).add(offset); shouldAutoPan = true;
        }
    }

    function addInstance(idx, x, y, z, rotY, colorIdx, highDetail) {
        dummy.position.set(x, y, z); dummy.rotation.set(0, rotY, 0); 
        dummy.scale.setScalar(1.0 + Math.random() * 0.1); 
        dummy.updateMatrix();
        imBody.setMatrixAt(idx, dummy.matrix);
        color.setHex(COLORS.lids[colorIdx]); imLid.setColorAt(idx, color); imLid.setMatrixAt(idx, dummy.matrix);
        if(highDetail) {
            instanceData.push({ x: x, y: y, z: z, rotY: rotY, phase: Math.random() * Math.PI * 2 });
            dummy.position.set(x - 0.32, y + 0.1, z - 0.25); dummy.updateMatrix(); imWheelLeft.setMatrixAt(idx, dummy.matrix);
            dummy.position.set(x + 0.32, y + 0.1, z - 0.25); dummy.updateMatrix(); imWheelRight.setMatrixAt(idx, dummy.matrix);
        }
    }

    // --- 5. PLAYER CONTROLLER ---
    let playerModeActive = false;
    const playerGroup = new THREE.Group();
    const playerHeight = 1.8;
    const playerRadius = 0.3;
    
    // Create Player Mesh
    const pMat = new THREE.MeshToonMaterial({ color: COLORS.player });
    const pGeo = new THREE.CylinderGeometry(playerRadius, playerRadius, playerHeight, 16);
    pGeo.translate(0, playerHeight/2, 0); // Pivot at feet
    const playerMesh = new THREE.Mesh(pGeo, pMat);
    playerMesh.castShadow = true;
    playerGroup.add(playerMesh);

    // Direction indicator (Eyes)
    const eyeGeo = new THREE.BoxGeometry(0.4, 0.2, 0.2);
    const eyeMat = new THREE.MeshBasicMaterial({color: 0xffffff});
    const eyes = new THREE.Mesh(eyeGeo, eyeMat);
    eyes.position.set(0, 1.5, 0.2);
    playerGroup.add(eyes);
    
    playerGroup.position.set(5, 0, 5);
    playerGroup.visible = false;
    scene.add(playerGroup);

    const keys = { w: false, a: false, s: false, d: false };
    window.addEventListener('keydown', (e) => { 
        if(e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true; 
    });
    window.addEventListener('keyup', (e) => { 
        if(e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false; 
    });

    const playerVel = new THREE.Vector3();
    const speed = 0.025;
    const friction = 0.8;

    function checkCollision(newPos) {
        // 1. Static Obstacles
        for (let ob of obstacles) {
            const dx = newPos.x - ob.x;
            const dz = newPos.z - ob.z;
            const distSq = dx*dx + dz*dz;
            const minDist = ob.r + playerRadius;
            if (distSq < minDist * minDist) {
                const dist = Math.sqrt(distSq);
                const push = (minDist - dist) / dist;
                newPos.x += dx * push;
                newPos.z += dz * push;
            }
        }

        // 2. Bin Collision (Spatial Hash)
        const cx = Math.floor(newPos.x / CHUNK_SIZE);
        const cz = Math.floor(newPos.z / CHUNK_SIZE);

        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                const key = `${cx + i},${cz + j}`;
                const binList = binChunks.get(key);
                if (binList) {
                    for (let bin of binList) {
                        const dx = newPos.x - bin.x;
                        const dz = newPos.z - bin.z;
                        const distSq = dx*dx + dz*dz;
                        const minDist = bin.r + playerRadius; 
                        if (distSq < minDist * minDist) {
                            const dist = Math.sqrt(distSq);
                            // Normalize push vector
                            const pushForce = 0.5; // Soft push
                            if (dist > 0.001) {
                                const pushX = (dx / dist) * (minDist - dist);
                                const pushZ = (dz / dist) * (minDist - dist);
                                newPos.x += pushX;
                                newPos.z += pushZ;
                            }
                        }
                    }
                }
            }
        }
        
        return newPos;
    }

    function updatePlayerPhysics() {
        if (!playerModeActive) return;

        // Input relative to camera
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        right.y = 0; right.normalize();

        if (keys.w) playerVel.add(forward.multiplyScalar(speed));
        if (keys.s) playerVel.add(forward.multiplyScalar(-speed));
        if (keys.a) playerVel.add(right.multiplyScalar(-speed));
        if (keys.d) playerVel.add(right.multiplyScalar(speed));

        // Apply Velocity
        const nextPos = playerGroup.position.clone().add(playerVel);
        
        // Collision
        const resolvedPos = checkCollision(nextPos);
        playerGroup.position.copy(resolvedPos);

        // Rotation (Look at movement)
        if (playerVel.lengthSq() > 0.001) {
            const angle = Math.atan2(playerVel.x, playerVel.z);
            playerGroup.rotation.y = angle;
        }

        // Friction
        playerVel.multiplyScalar(friction);

        // Camera Follow
        const camTarget = playerGroup.position.clone().add(new THREE.Vector3(0, 1.5, 0));
        controls.target.lerp(camTarget, 0.1);
        
        if (camera.position.distanceTo(controls.target) > 15) {
            const dir = camera.position.clone().sub(controls.target).normalize();
            camera.position.lerp(controls.target.clone().add(dir.multiplyScalar(15)), 0.05);
        }
    }


    // --- 6. UI & STATE ---
    const slider = document.getElementById('binSlider');
    const input = document.getElementById('literInput');
    const txtBins = document.getElementById('binDisplay');
    const txtLiters = document.getElementById('literDisplay');
    const shellToggle = document.getElementById('shellToggle');
    const infillToggle = document.getElementById('infillToggle');
    const walkToggle = document.getElementById('walkToggle');
    const controlsHint = document.getElementById('controls-hint');
    
    // New Controls
    const modeSelect = document.getElementById('modeSelect');
    const directControls = document.getElementById('directControls');
    const rainControls = document.getElementById('rainControls');
    const rainMmInput = document.getElementById('rainMmInput');
    const areaInput = document.getElementById('areaInput');

    const minVal = Math.log(1); const maxVal = Math.log(2000000); const scale = (maxVal - minVal) / 1000;
    
    let userToggledShell = false;
    let userToggledInfill = false;
    let currentCount = 10;
    let currentMode = 'direct';
    
    shellToggle.addEventListener('change', () => { userToggledShell = true; populateScene(currentCount, false); });
    infillToggle.addEventListener('change', () => { userToggledInfill = true; populateScene(currentCount, false); });

    walkToggle.addEventListener('change', (e) => {
        playerModeActive = e.target.checked;
        playerGroup.visible = playerModeActive;
        shouldAutoPan = false;
        
        if (playerModeActive) {
            const offset = new THREE.Vector3(0, 5, 10);
            camera.position.copy(playerGroup.position).add(offset);
            controls.target.copy(playerGroup.position);
            controlsHint.classList.add('visible');
            
            const dist = playerGroup.position.length();
            if (validSlots.length > 0 && dist < Math.sqrt(validSlots[Math.min(currentCount, validSlots.length)-1].d)) {
                const edgeR = Math.sqrt(validSlots[Math.min(currentCount, validSlots.length)-1].d) + 2;
                playerGroup.position.set(edgeR, 0, 0);
                camera.position.copy(playerGroup.position).add(offset);
            }

        } else {
            controlsHint.classList.remove('visible');
            populateScene(currentCount, true);
        }
    });

    function getCountFromSlider(val) { return Math.floor(Math.exp(minVal + scale * val)); }
    function getSliderFromCount(count) { if(count < 1) count = 1; return (Math.log(count) - minVal) / scale; }

    function updateState(count, source) {
        if(count < 1) count = 1; if(count > 2000000) count = 2000000;
        currentCount = count;
        
        const liters = count * 120;
        txtBins.innerText = `${count.toLocaleString()} ${count === 1 ? 'bin' : 'bins'}`;
        txtLiters.innerText = `(${liters.toLocaleString()} L/s)`;
        
        // Sync Inputs depending on who triggered the update
        if (source !== 'input' && source !== 'rain') input.value = liters;
        if (source !== 'slider') slider.value = getSliderFromCount(count);
        
        if (!userToggledShell) {
            shellToggle.checked = (count >= 60000);
        }
        
        populateScene(count, source !== 'init');
    }

    function recalculateRain() {
        const mm = parseFloat(rainMmInput.value) || 0;
        const area = parseFloat(areaInput.value) || 0;
        
        // 1mm of rain on 1m^2 = 1 Liter.
        // Total Liters = mm * area.
        // This usually happens over an hour.
        const totalLitersPerHour = mm * area;
        
        // Convert to Liters Per Second (L/s)
        const lps = totalLitersPerHour / 3600;
        
        // Convert L/s to Bins (1 bin unit = 120 L/s in this vis)
        // Wait, standard visualizer logic: 10 bins = 1200 L/s. So 1 bin = 120 L/s.
        const binCount = Math.max(1, Math.ceil(lps / 120));
        
        updateState(binCount, 'rain');
    }

    slider.addEventListener('input', (e) => { 
        if(currentMode === 'rain') {
            // If user drags slider in rain mode, switch back to direct?
            // Or just update display but keep rain mode UI?
            // Let's force switch to direct for clarity or just update visualization
            modeSelect.value = 'direct';
            toggleMode();
        }
        updateState(getCountFromSlider(parseInt(e.target.value)), 'slider'); 
    });
    
    input.addEventListener('change', (e) => { 
        const val = parseInt(e.target.value); 
        if(!val) return; 
        updateState(Math.ceil(val / 120), 'input'); 
    });

    rainMmInput.addEventListener('input', recalculateRain);
    areaInput.addEventListener('input', recalculateRain);

    function toggleMode() {
        currentMode = modeSelect.value;
        if (currentMode === 'direct') {
            directControls.classList.remove('hidden');
            rainControls.classList.add('hidden');
            updateState(getCountFromSlider(parseInt(slider.value)), 'slider');
        } else {
            directControls.classList.add('hidden');
            rainControls.classList.remove('hidden');
            recalculateRain();
        }
    }
    modeSelect.addEventListener('change', toggleMode);

    // --- MOBILE TOGGLE LOGIC ---
    const mobileToggle = document.getElementById('mobile-toggle');
    const renderingControls = document.getElementById('rendering-controls');
    let isCollapsed = true;

    mobileToggle.addEventListener('click', () => {
        isCollapsed = !isCollapsed;
        if(isCollapsed) {
            renderingControls.classList.add('collapsed');
            mobileToggle.innerText = 'ðŸ”½ Performance Options';
        } else {
            renderingControls.classList.remove('collapsed');
            mobileToggle.innerText = 'ðŸ”¼ Hide Options';
        }
    });

    updateState(10, 'init');

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05; controls.target.set(0, 0.5, 0);
    controls.addEventListener('start', () => { shouldAutoPan = false; });
    
    function animate() {
        requestAnimationFrame(animate);
        
        if (playerModeActive) {
            updatePlayerPhysics();
        } else if (shouldAutoPan) {
            camera.position.lerp(targetCameraPos, 0.05); controls.target.lerp(targetLookAt, 0.05);
            if(camera.position.distanceTo(targetCameraPos) < 0.5) shouldAutoPan = false;
        }
        
        controls.update();
        const dist = camera.position.distanceTo(controls.target); scene.fog.near = dist * 0.5; scene.fog.far = dist * 5.0;

        if(isHighPoly && imBody && instanceData.length > 0) {
             const t = Date.now() * 0.005; const animCount = Math.min(instanceData.length, 5000); 
             for(let i = 0; i < animCount; i++) {
                 const data = instanceData[i]; const wobbleZ = Math.sin(t + data.phase) * 0.03;
                 dummy.position.set(data.x, data.y, data.z); dummy.rotation.set(0, data.rotY, wobbleZ); dummy.updateMatrix();
                 imBody.setMatrixAt(i, dummy.matrix); imLid.setMatrixAt(i, dummy.matrix);
                 dummy.rotation.set(0, data.rotY, wobbleZ); 
                 dummy.position.set(data.x - 0.32, data.y + 0.1, data.z - 0.25); dummy.updateMatrix(); imWheelLeft.setMatrixAt(i, dummy.matrix);
                 dummy.position.set(data.x + 0.32, data.y + 0.1, data.z - 0.25); dummy.updateMatrix(); imWheelRight.setMatrixAt(i, dummy.matrix);
             }
             imBody.instanceMatrix.needsUpdate = true; imLid.instanceMatrix.needsUpdate = true;
             imWheelLeft.instanceMatrix.needsUpdate = true; imWheelRight.instanceMatrix.needsUpdate = true;
        }
        renderer.render(scene, camera);
    }
    
    function updateDimensions() {
         if (!canvasWrapper.clientWidth) return;
         const width = canvasWrapper.clientWidth;
         const height = canvasWrapper.clientHeight;
         renderer.setSize(width, height);
         camera.aspect = width / height;
         camera.updateProjectionMatrix();
         renderer.render(scene, camera);
    }
    const resizeObserver = new ResizeObserver(() => { updateDimensions(); });
    resizeObserver.observe(canvasWrapper);
    window.addEventListener('resize', updateDimensions);
    animate();
</script>
</body>
</html>
