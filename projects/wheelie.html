<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wheelie bins p/s</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', -apple-system, sans-serif; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
            min-width: 260px;
            user-select: none;
            color: #1a472a;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 800;
            text-transform: lowercase;
            letter-spacing: -0.5px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
            padding-bottom: 10px;
        }

        .display-group {
            text-align: center;
            margin-bottom: 20px;
        }

        .big-number {
            font-size: 28px;
            font-weight: 800;
            display: block;
            color: #1a472a;
            line-height: 1.1;
        }

        .sub-text {
            font-size: 14px;
            color: #666;
            font-weight: 500;
            margin-top: 4px;
            display: block;
        }

        /* Controls */
        label { 
            font-size: 11px; 
            font-weight: 700; 
            color: #888; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        input[type=range] { 
            width: 100%; 
            accent-color: #2E8B57; 
            cursor: pointer; 
            height: 6px;
        }

        .input-wrapper {
            position: relative;
            margin-top: 5px;
        }

        input[type=number] {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-family: inherit;
            font-weight: 600;
            color: #333;
            box-sizing: border-box;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        input[type=number]:focus {
            border-color: #2E8B57;
        }

        .unit {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
        }

        /* Footer Styling */
        .footer-info {
            margin-top: 25px;
            padding-top: 15px;
            border-top: 1px solid rgba(0,0,0,0.05);
            text-align: left;
            font-size: 11px;
            color: #888;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .footer-info span {
            display: block;
        }

        .footer-info a {
            color: #888;
            text-decoration: none;
            transition: color 0.2s;
        }

        .footer-info a:hover {
            color: #2E8B57;
        }

    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="ui-container">
    <h2>wheelie bins p/s</h2>
    
    <div class="display-group">
        <span id="binDisplay" class="big-number">10 bins</span>
        <span id="literDisplay" class="sub-text">(1,200 L/s)</span>
    </div>

    <label>Count</label>
    <input type="range" id="binSlider" min="1" max="1000" value="10">

    <label>Flow Rate</label>
    <div class="input-wrapper">
        <input type="number" id="literInput" value="1200" step="120">
        <span class="unit">L/s</span>
    </div>

    <div class="footer-info">
        <span>Bins, Bench, and Gumtree to Scale</span>
    </div>
</div>

<script>
    // --- 1. CONFIGURATION ---
    const COLORS = {
        grass: 0x5cb85c,
        grassBlade: 0x4da04d,
        binBody: 0x1a472a, 
        lids: [0xd9534f, 0xf0ad4e, 0x3366cc], // Red, Yellow, Blue
        wheels: 0x222222,
        sky: 0x87CEEB,
        wood: 0x8B5A2B,
        treeTrunk: 0xE0E0E0,
        treeLeaves: 0x2E8B57
    };

    // --- 2. SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.sky);
    scene.fog = new THREE.Fog(COLORS.sky, 40, 160);

    const aspect = window.innerWidth / window.innerHeight;
    let frustumSize = 20; 
    const camera = new THREE.OrthographicCamera(
        frustumSize * aspect / -2, frustumSize * aspect / 2,
        frustumSize / 2, frustumSize / -2,
        1, 1500
    );
    camera.position.set(30, 30, 30); 
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(20, 50, 20);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(4096, 4096);
    dirLight.shadow.bias = -0.0005;
    dirLight.shadow.normalBias = 0.02;
    scene.add(dirLight);

    // Floor
    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300),
        new THREE.MeshToonMaterial({ color: COLORS.grass })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // --- 3. ENVIRONMENT ---
    const obstacles = [];
    function registerObstacle(x, z, radius) {
        obstacles.push({ x, z, r: radius });
    }

    function createEnvironment() {
        const envGroup = new THREE.Group();

        // Tree
        const treeGroup = new THREE.Group();
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.6, 3, 7),
            new THREE.MeshToonMaterial({ color: COLORS.treeTrunk })
        );
        trunk.position.y = 1.5;
        trunk.castShadow = true; trunk.receiveShadow = true;
        treeGroup.add(trunk);

        const leafGeo = new THREE.IcosahedronGeometry(1.5, 0);
        const leafMat = new THREE.MeshToonMaterial({ color: COLORS.treeLeaves });
        [[0,3.5,0], [1,3,1], [-1,3.2,-0.5], [0.5,4,-1]].forEach(p => {
            const l = new THREE.Mesh(leafGeo, leafMat);
            l.position.set(...p);
            l.castShadow = true;
            l.scale.setScalar(0.8 + Math.random()*0.4);
            treeGroup.add(l);
        });
        
        treeGroup.position.set(-8, 0, -5);
        envGroup.add(treeGroup);
        registerObstacle(-8, -5, 2.5);

        // Bench
        const benchGroup = new THREE.Group();
        const woodMat = new THREE.MeshToonMaterial({ color: COLORS.wood });
        const seat = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.45), woodMat);
        seat.position.y = 0.45; seat.castShadow = true; benchGroup.add(seat);
        const back = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.05), woodMat);
        back.position.set(0, 0.85, -0.2); back.castShadow = true; benchGroup.add(back);
        const legGeo = new THREE.BoxGeometry(0.1, 0.45, 0.4);
        const l1 = new THREE.Mesh(legGeo, woodMat); l1.position.set(-0.6, 0.225, 0); benchGroup.add(l1);
        const l2 = new THREE.Mesh(legGeo, woodMat); l2.position.set(0.6, 0.225, 0); benchGroup.add(l2);

        benchGroup.position.set(-3, 0, -2);
        benchGroup.rotation.y = 0.2;
        envGroup.add(benchGroup);
        registerObstacle(-3, -2, 1.8);

        scene.add(envGroup);
    }
    createEnvironment();

    // Grass
    function createGrass() {
        const count = 5000;
        const mesh = new THREE.InstancedMesh(
            new THREE.ConeGeometry(0.05, 0.3, 3).translate(0, 0.15, 0),
            new THREE.MeshToonMaterial({ color: COLORS.grassBlade }),
            count
        );
        const dummy = new THREE.Object3D();
        for(let i=0; i<count; i++) {
            dummy.position.set((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
            dummy.rotation.y = Math.random() * Math.PI;
            dummy.scale.setScalar(0.5 + Math.random());
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
        }
        mesh.receiveShadow = true;
        scene.add(mesh);
    }
    createGrass();

    // --- 4. BINS ---
    const bodyGeo = new THREE.BoxGeometry(0.58, 0.9, 0.6); bodyGeo.translate(0, 0.55, 0); 
    const lidGeo = new THREE.BoxGeometry(0.62, 0.05, 0.65); lidGeo.translate(0, 1.02, 0);
    const handleGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 8); handleGeo.rotateZ(Math.PI/2); handleGeo.translate(0, 0.95, -0.35);
    const wheelGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.08, 16); wheelGeo.rotateZ(Math.PI/2);
    const bodyMat = new THREE.MeshToonMaterial({ color: COLORS.binBody });
    const wheelMat = new THREE.MeshToonMaterial({ color: COLORS.wheels });

    const binsArray = [];
    
    function createBinInstance(x, z, index) {
        const g = new THREE.Group();
        const b = new THREE.Mesh(bodyGeo, bodyMat); b.castShadow=true; b.receiveShadow=true; g.add(b);
        const h = new THREE.Mesh(handleGeo, bodyMat); h.castShadow=true; g.add(h);
        const w1 = new THREE.Mesh(wheelGeo, wheelMat); w1.position.set(-0.32,0.1,-0.25); w1.castShadow=true; g.add(w1);
        const w2 = new THREE.Mesh(wheelGeo, wheelMat); w2.position.set(0.32,0.1,-0.25); w2.castShadow=true; g.add(w2);
        
        const lidC = COLORS.lids[Math.floor(Math.random()*COLORS.lids.length)];
        const lid = new THREE.Mesh(lidGeo, new THREE.MeshToonMaterial({color:lidC})); lid.castShadow=true; g.add(lid);

        g.position.set(x,0,z);
        g.rotation.y = (Math.random()-0.5)*0.5;
        g.userData = { offset: index*0.2 };
        return g;
    }

    let targetFrustumSize = 10;
    
    function populateScene(targetCount) {
        binsArray.forEach(b => scene.remove(b));
        binsArray.length = 0;

        const spacing = 1.5;
        const candidates = [];
        const radius = Math.ceil(Math.sqrt(targetCount) * 1.5);
        
        for (let x = -radius; x <= radius; x++) {
            for (let z = -radius; z <= radius; z++) {
                const wx = x*spacing; const wz = z*spacing;
                let blocked = false;
                for(let ob of obstacles) {
                    if(Math.sqrt((wx-ob.x)**2 + (wz-ob.z)**2) < ob.r) blocked = true;
                }
                if(!blocked) candidates.push({x:wx, z:wz, d:Math.sqrt(wx*wx+wz*wz)});
            }
        }
        candidates.sort((a,b) => a.d - b.d);
        
        const count = Math.min(targetCount, candidates.length);
        let minX=0, maxX=0, minZ=0, maxZ=0;
        
        for(let i=0; i<count; i++) {
            const b = createBinInstance(candidates[i].x, candidates[i].z, i);
            scene.add(b);
            binsArray.push(b);
            minX = Math.min(minX, candidates[i].x); maxX = Math.max(maxX, candidates[i].x);
            minZ = Math.min(minZ, candidates[i].z); maxZ = Math.max(maxZ, candidates[i].z);
        }

        const maxDim = Math.max(maxX-minX, maxZ-minZ);
        targetFrustumSize = Math.max(10, maxDim * 1.4);
        
        const sd = Math.max(15, maxDim * 0.8);
        dirLight.shadow.camera.left = -sd; dirLight.shadow.camera.right = sd;
        dirLight.shadow.camera.top = sd; dirLight.shadow.camera.bottom = -sd;
        dirLight.shadow.camera.updateProjectionMatrix();
    }

    // --- 5. UI LOGIC ---
    const slider = document.getElementById('binSlider');
    const input = document.getElementById('literInput');
    const txtBins = document.getElementById('binDisplay');
    const txtLiters = document.getElementById('literDisplay');

    function updateState(count, source) {
        if(count < 1) count = 1;
        if(count > 1000) count = 1000;

        const liters = count * 120;

        populateScene(count);

        txtBins.innerText = `${count} ${count === 1 ? 'bin' : 'bins'}`;
        txtLiters.innerText = `(${liters.toLocaleString()} L/s)`;

        if(source !== 'input') {
            input.value = liters;
        }
        if(source !== 'slider') {
            slider.value = count;
        }
    }

    slider.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        updateState(val, 'slider');
    });

    input.addEventListener('input', (e) => {
        const val = parseInt(e.target.value);
        if(!val) return;
        const bins = Math.ceil(val / 120);
        updateState(bins, 'input');
    });

    // Initial Load
    updateState(10, 'init');

    // --- 6. ANIMATION ---
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI/2.1;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        
        const cs = camera.top - camera.bottom;
        if(Math.abs(cs - targetFrustumSize) > 0.1) {
             const ns = THREE.MathUtils.lerp(cs, targetFrustumSize, 0.05);
             camera.left = -ns * aspect / 2; camera.right = ns * aspect / 2;
             camera.top = ns / 2; camera.bottom = -ns / 2;
             camera.updateProjectionMatrix();
        }

        const t = Date.now() * 0.005;
        binsArray.forEach(b => {
            const h = Math.sin(t + b.userData.offset);
            b.position.y = (h > 0.5) ? (h-0.5)*0.05 : 0;
            b.rotation.z = Math.sin(t + b.userData.offset)*0.03;
        });
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        const aspect = window.innerWidth / window.innerHeight;
        const h = camera.top - camera.bottom;
        camera.left = -h * aspect / 2; camera.right = h * aspect / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>