<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheelie Bin Scale Visualiser</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', -apple-system, sans-serif; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(12px);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.6);
            min-width: 280px;
            user-select: none;
            color: #1a472a;
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 800;
            text-transform: lowercase;
            letter-spacing: -0.5px;
            border-bottom: 2px solid rgba(0,0,0,0.05);
            padding-bottom: 10px;
        }

        .display-group { text-align: center; margin-bottom: 20px; }
        
        .big-number {
            font-size: 28px;
            font-weight: 800;
            display: block;
            color: #1a472a;
            line-height: 1.1;
        }

        .sub-text {
            font-size: 14px;
            color: #666;
            font-weight: 500;
            margin-top: 4px;
            display: block;
        }

        /* Controls */
        label { 
            font-size: 11px; 
            font-weight: 700; 
            color: #888; 
            text-transform: uppercase; 
            letter-spacing: 1px;
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        input[type=range] { 
            width: 100%; 
            accent-color: #2E8B57; 
            cursor: pointer; 
            height: 6px;
        }

        .input-wrapper { position: relative; margin-top: 5px; }

        input[type=number] {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-family: inherit;
            font-weight: 600;
            color: #333;
            box-sizing: border-box;
            font-size: 14px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        input[type=number]:focus { border-color: #2E8B57; }

        .unit {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #888;
            font-size: 12px;
            font-weight: 600;
            pointer-events: none;
        }

        .warning {
            color: #d9534f;
            font-size: 11px;
            font-weight: 600;
            margin-top: 10px;
            display: none;
        }

        .footer-note {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(0,0,0,0.1);
            font-size: 11px;
            color: #555;
            text-align: center;
            font-style: italic;
            opacity: 0.8;
            line-height: 1.4;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="ui-container">
    <h2>Wheelie Bin Flow Simulator</h2>
    
    <div class="display-group">
        <span id="binDisplay" class="big-number">10 bins</span>
        <span id="literDisplay" class="sub-text">(1,200 L/s)</span>
    </div>

    <label>Count (Logarithmic Scale)</label>
    <input type="range" id="binSlider" min="0" max="1000" value="10">

    <label>Flow Rate</label>
    <div class="input-wrapper">
        <input type="number" id="literInput" value="1200">
        <span class="unit">L/s</span>
    </div>

    <div id="perfWarning" class="warning">High count: Simplified geometry active</div>

    <div class="footer-note">
        All bins, objects, and landmarks<br>are rendered to scale.
    </div>
</div>

<script>
    // --- 1. CONFIGURATION ---
    const COLORS = {
        grass: 0x5cb85c,
        grassBlade: 0x4da04d,
        binBody: 0x1a472a, 
        lids: [0xd9534f, 0xf0ad4e, 0x3366cc], 
        wheels: 0x222222,
        sky: 0x87CEEB,
        wood: 0x8B5A2B,
        treeTrunk: 0xE0E0E0,
        treeLeaves: 0x2E8B57,
        crownGlass: 0xAACCFF,
        bananaYellow: 0xFFE135, 
        bananaTip: 0x4A3328,
        concrete: 0x999999
    };

    const BIN_SPACING = 0.9; 
    const BIN_HEIGHT = 1.1;
    const GRID_RADIUS = 70; // 140m Diameter

    // --- 2. SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(COLORS.sky);
    scene.fog = new THREE.Fog(COLORS.sky, 100, 600);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 15000);
    
    // ** MODIFICATION: Super close start **
    camera.position.set(5, 5, 5); 
    
    // Camera Animation State
    const targetCameraPos = new THREE.Vector3(5, 5, 5);
    const targetLookAt = new THREE.Vector3(0, 0.5, 0);
    let shouldAutoPan = false;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(50, 100, 50);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    dirLight.shadow.bias = -0.0005;
    scene.add(dirLight);

    const d = 80;
    dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;

    // Floor
    const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(5000, 5000),
        new THREE.MeshToonMaterial({ color: COLORS.grass })
    );
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // --- 3. ENVIRONMENT & LANDMARKS ---
    const obstacles = [];
    function registerObstacle(x, z, radius) {
        obstacles.push({ x, z, rSq: radius * radius });
    }

    let validSlots = [];

    function createEnvironment() {
        const envGroup = new THREE.Group();

        // -- Tree --
        const treeGroup = new THREE.Group();
        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.6, 3, 7),
            new THREE.MeshToonMaterial({ color: COLORS.treeTrunk })
        );
        trunk.position.y = 1.5;
        trunk.castShadow = true; trunk.receiveShadow = true;
        treeGroup.add(trunk);

        const leafGeo = new THREE.IcosahedronGeometry(1.5, 0);
        const leafMat = new THREE.MeshToonMaterial({ color: COLORS.treeLeaves });
        [[0,3.5,0], [1,3,1], [-1,3.2,-0.5], [0.5,4,-1]].forEach(p => {
            const l = new THREE.Mesh(leafGeo, leafMat);
            l.position.set(...p);
            l.castShadow = true;
            l.scale.setScalar(0.8 + Math.random()*0.4);
            treeGroup.add(l);
        });
        
        treeGroup.position.set(-8, 0, -5);
        envGroup.add(treeGroup);
        registerObstacle(-8, -5, 3.5); 

        // -- Bench --
        const benchGroup = new THREE.Group();
        const woodMat = new THREE.MeshToonMaterial({ color: COLORS.wood });
        const seat = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.45), woodMat);
        seat.position.y = 0.45; seat.castShadow = true; benchGroup.add(seat);
        const back = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.4, 0.05), woodMat);
        back.position.set(0, 0.85, -0.2); back.castShadow = true; benchGroup.add(back);
        
        const legGeo = new THREE.BoxGeometry(0.1, 0.45, 0.4);
        const l1 = new THREE.Mesh(legGeo, woodMat); l1.position.set(-0.6, 0.225, 0); benchGroup.add(l1);
        const l2 = new THREE.Mesh(legGeo, woodMat); l2.position.set(0.6, 0.225, 0); benchGroup.add(l2);

        benchGroup.position.set(-3, 0, -2);
        benchGroup.rotation.y = 0.2;
        envGroup.add(benchGroup);
        registerObstacle(-3, -2, 2.5);

        scene.add(envGroup);
    }
    
    function createLandmarks() {
        const landmarkGroup = new THREE.Group();

        // --- 1. THE BIG BANANA ---
        const bananaGroup = new THREE.Group();
        
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-6, 3.8, 0),
            new THREE.Vector3(-3, 1.2, 0),
            new THREE.Vector3(0, 0.6, 0),
            new THREE.Vector3(3, 1.2, 0),
            new THREE.Vector3(6, 3.8, 0)
        ]);

        const segments = 48;
        const radialSegments = 16;
        const tubeGeo = new THREE.TubeGeometry(curve, segments, 1, radialSegments, false);
        
        const pos = tubeGeo.attributes.position;
        const totalVerts = pos.count;
        
        for(let i=0; i <= segments; i++) {
            const u = i / segments;
            const scale = 0.25 + Math.sin(u * Math.PI) * 1.15;
            const center = curve.getPointAt(u);
            
            for(let j=0; j <= radialSegments; j++) {
                const idx = i * (radialSegments + 1) + j;
                if(idx >= totalVerts) continue;
                const px = pos.getX(idx); const py = pos.getY(idx); const pz = pos.getZ(idx);
                const dx = px - center.x; const dy = py - center.y; const dz = pz - center.z;

                pos.setXYZ(idx, center.x + dx * scale, center.y + dy * scale, center.z + dz * scale);
            }
        }
        tubeGeo.computeVertexNormals();

        const bananaMat = new THREE.MeshToonMaterial({ 
            color: COLORS.bananaYellow,
            emissive: 0x222200 
        });
        const bananaBody = new THREE.Mesh(tubeGeo, bananaMat);
        bananaBody.castShadow = true;
        bananaGroup.add(bananaBody);

        const tipMat = new THREE.MeshToonMaterial({ color: COLORS.bananaTip });
        const tipGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const tip1 = new THREE.Mesh(tipGeo, tipMat); tip1.position.set(-6, 3.8, 0);
        const tip2 = new THREE.Mesh(tipGeo, tipMat); tip2.position.set(6, 3.8, 0);
        bananaGroup.add(tip1); bananaGroup.add(tip2);

        const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 3.7, 8);
        const pillarMat = new THREE.MeshToonMaterial({ color: COLORS.concrete });
        
        const leg1 = new THREE.Mesh(pillarGeo, pillarMat); 
        leg1.position.set(-3, -0.65, 0); 
        bananaGroup.add(leg1);

        const leg2 = new THREE.Mesh(pillarGeo, pillarMat); 
        leg2.position.set(3, -0.65, 0); 
        bananaGroup.add(leg2);

        bananaGroup.position.set(-35, 2.5, 5); 
        bananaGroup.rotation.set(0, Math.PI / 6, 0); 
        landmarkGroup.add(bananaGroup);
        registerObstacle(-35, 5, 8);

        // --- 2. CROWN SYDNEY ---
        const crownHeight = 271.3;
        const segmentsY = 80; const segmentsR = 60;
        const crownGeo = new THREE.CylinderGeometry(1, 1, crownHeight, segmentsR, segmentsY, true);
        const cPos = crownGeo.attributes.position;
        
        for(let i=0; i < cPos.count; i++) {
            let x = cPos.getX(i); let y = cPos.getY(i); let z = cPos.getZ(i);
            const normY = (y + crownHeight/2) / crownHeight;
            let baseR = 25; 
            let taper = 1.0;
            if(normY < 0.3) taper = 1.0 + (normY / 0.3) * 0.2;
            else taper = 1.2 - ((normY - 0.3) / 0.7) * 0.8;
            
            const angle = Math.atan2(z, x);
            const petal = 1 + 0.2 * Math.sin(3 * angle);
            const twistAngle = normY * (Math.PI / 3); 
            const cosT = Math.cos(twistAngle); const sinT = Math.sin(twistAngle);
            
            let currentR = baseR * taper * petal;
            let nx = Math.cos(angle) * currentR; let nz = Math.sin(angle) * currentR;
            cPos.setXYZ(i, nx * cosT - nz * sinT, y + crownHeight/2, nx * sinT + nz * cosT);
        }
        crownGeo.computeVertexNormals();
        
        const glassMat = new THREE.MeshStandardMaterial({ 
            color: COLORS.crownGlass, metalness: 0.6, roughness: 0.2, transparent: true, opacity: 0.85
        });
        const crown = new THREE.Mesh(crownGeo, glassMat);
        crown.castShadow = true;
        crown.position.set(0, 0, -80); 
        landmarkGroup.add(crown);
        registerObstacle(0, -80, 35);

        for(let h=10; h<271; h+=15) {
            const normY = h/271;
            let taper = 1.0;
            if(normY < 0.3) taper = 1.0 + (normY / 0.3) * 0.2;
            else taper = 1.2 - ((normY - 0.3) / 0.7) * 0.8;
            
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(25 * taper, 0.5, 4, 60), 
                new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.3})
            );
            ring.rotation.x = Math.PI/2;
            ring.rotation.z = normY * (Math.PI / 3);
            ring.position.set(0, h, -80);
            landmarkGroup.add(ring);
        }

        scene.add(landmarkGroup);
    }

    function generateSlots() {
        validSlots = [];
        const steps = Math.ceil(GRID_RADIUS / BIN_SPACING);
        
        for(let x = -steps; x <= steps; x++) {
            for(let z = -steps; z <= steps; z++) {
                const wx = x * BIN_SPACING;
                const wz = z * BIN_SPACING;
                
                const distSq = wx*wx + wz*wz;
                if(distSq > GRID_RADIUS * GRID_RADIUS) continue;

                let blocked = false;
                for(let ob of obstacles) {
                    if((wx - ob.x)**2 + (wz - ob.z)**2 < ob.rSq) {
                        blocked = true; break;
                    }
                }
                if(!blocked) validSlots.push({ x: wx, z: wz, d: distSq });
            }
        }
        validSlots.sort((a, b) => a.d - b.d);
    }

    createEnvironment();
    createLandmarks();
    generateSlots();

    // Grass
    function createGrass() {
        const count = 5000;
        const mesh = new THREE.InstancedMesh(
            new THREE.ConeGeometry(0.05, 0.3, 3).translate(0, 0.15, 0),
            new THREE.MeshToonMaterial({ color: COLORS.grassBlade }),
            count
        );
        const dummy = new THREE.Object3D();
        for(let i=0; i<count; i++) {
            dummy.position.set((Math.random()-0.5)*250, 0, (Math.random()-0.5)*250);
            dummy.rotation.y = Math.random() * Math.PI;
            dummy.scale.setScalar(0.5 + Math.random());
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
        }
        mesh.receiveShadow = true;
        scene.add(mesh);
    }
    createGrass();

    // --- 4. INSTANCED BINS ---
    const boxBodyGeo = new THREE.BoxGeometry(0.58, 0.9, 0.6); boxBodyGeo.translate(0, 0.45, 0);
    const boxLidGeo = new THREE.BoxGeometry(0.62, 0.05, 0.65); boxLidGeo.translate(0, 0.925, 0);
    const boxWheelGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.08, 8); boxWheelGeo.rotateZ(Math.PI/2);
    
    const bodyMat = new THREE.MeshToonMaterial({ color: COLORS.binBody });
    const lidMat = new THREE.MeshToonMaterial({ color: 0xffffff });
    const wheelMat = new THREE.MeshToonMaterial({ color: COLORS.wheels });

    let imBody, imLid, imWheelLeft, imWheelRight;
    let isHighPoly = false;
    let instanceData = []; 

    function disposeInstancedMeshes() {
        if(imBody) { scene.remove(imBody); imBody.dispose(); imBody = null; }
        if(imLid) { scene.remove(imLid); imLid.dispose(); imLid = null; }
        if(imWheelLeft) { scene.remove(imWheelLeft); imWheelLeft.dispose(); imWheelLeft = null; }
        if(imWheelRight) { scene.remove(imWheelRight); imWheelRight.dispose(); imWheelRight = null; }
    }

    function setupInstancedMeshes(count, highDetail) {
        disposeInstancedMeshes();
        isHighPoly = highDetail;

        imBody = new THREE.InstancedMesh(boxBodyGeo, bodyMat, count);
        imBody.castShadow = true; imBody.receiveShadow = true;
        scene.add(imBody);

        imLid = new THREE.InstancedMesh(boxLidGeo, lidMat, count);
        imLid.castShadow = true; 
        scene.add(imLid);

        if(highDetail) {
            imWheelLeft = new THREE.InstancedMesh(boxWheelGeo, wheelMat, count);
            imWheelRight = new THREE.InstancedMesh(boxWheelGeo, wheelMat, count);
            scene.add(imWheelLeft);
            scene.add(imWheelRight);
        }
    }

    const dummy = new THREE.Object3D();
    const color = new THREE.Color();

    function populateScene(targetCount, doAutoFit = true) {
        const highDetail = targetCount < 5000;
        setupInstancedMeshes(targetCount, highDetail);
        document.getElementById('perfWarning').style.display = highDetail ? 'none' : 'block';

        instanceData = []; 
        let placed = 0;
        let layerIndex = 0;
        let slotIndex = 0;
        const slotsCount = validSlots.length;
        const maxAttempts = targetCount * 2;
        let attempts = 0;

        while(placed < targetCount && attempts < maxAttempts) {
            attempts++;
            if (slotIndex >= slotsCount) { slotIndex = 0; layerIndex++; }

            const slot = validSlots[slotIndex];
            const wx = slot.x; const wz = slot.z;
            const wy = layerIndex * BIN_HEIGHT;
            const rotY = (Math.random() - 0.5) * 0.2;

            if(highDetail) {
                instanceData.push({
                    x: wx, y: wy, z: wz, 
                    rotY: rotY,
                    phase: Math.random() * Math.PI * 2
                });
            }

            dummy.position.set(wx, wy, wz);
            dummy.rotation.set(0, rotY, 0);
            dummy.scale.setScalar(1);
            dummy.updateMatrix();

            imBody.setMatrixAt(placed, dummy.matrix);
            
            // Layer color logic
            const colorIndex = (slotIndex + layerIndex) % 3;
            color.setHex(COLORS.lids[colorIndex]);
            
            imLid.setColorAt(placed, color);
            imLid.setMatrixAt(placed, dummy.matrix);

            if(highDetail) {
                dummy.rotation.set(0, rotY, 0); 
                dummy.position.set(wx - 0.32, wy + 0.1, wz - 0.25);
                dummy.updateMatrix();
                imWheelLeft.setMatrixAt(placed, dummy.matrix);

                dummy.position.set(wx + 0.32, wy + 0.1, wz - 0.25);
                dummy.updateMatrix();
                imWheelRight.setMatrixAt(placed, dummy.matrix);
            }

            placed++; slotIndex++;
        }

        imBody.instanceMatrix.needsUpdate = true;
        imLid.instanceMatrix.needsUpdate = true;
        if(imLid.instanceColor) imLid.instanceColor.needsUpdate = true;
        
        if(highDetail) {
            imWheelLeft.instanceMatrix.needsUpdate = true;
            imWheelRight.instanceMatrix.needsUpdate = true;
        }

        const currentRadius = (layerIndex === 0) ? Math.sqrt(validSlots[Math.min(placed, slotsCount)-1].d) : GRID_RADIUS;
        const currentHeight = (layerIndex + 1) * BIN_HEIGHT;
        
        const maxDim = Math.max(currentRadius * 2.2, currentHeight * 1.2, 280); 
        const camSize = Math.max(80, maxDim * 0.6);
        dirLight.shadow.camera.left = -camSize; dirLight.shadow.camera.right = camSize;
        dirLight.shadow.camera.top = camSize; dirLight.shadow.camera.bottom = -camSize;
        dirLight.shadow.camera.updateProjectionMatrix();

        // Auto-zoom logic
        if (doAutoFit) {
            const pileCenterY = currentHeight / 2;
            const pileCenter = new THREE.Vector3(0, pileCenterY, 0);
            targetLookAt.copy(pileCenter);

            const boundSize = Math.max(currentRadius * 1.5, currentHeight);
            
            // ** MODIFICATION: Calculate min distance dynamically **
            // If the boundSize is tiny (only a few bins), we allow it to get very close (8 units)
            // Otherwise we scale out based on the size of the pile.
            const dist = 8 + (boundSize * 1.8);

            const offset = new THREE.Vector3(1, 0.8, 1).normalize().multiplyScalar(dist);
            targetCameraPos.copy(pileCenter).add(offset);
            
            shouldAutoPan = true;
        }
    }

    const slider = document.getElementById('binSlider');
    const input = document.getElementById('literInput');
    const txtBins = document.getElementById('binDisplay');
    const txtLiters = document.getElementById('literDisplay');

    const minVal = Math.log(1);
    const maxVal = Math.log(2000000);
    const scale = (maxVal - minVal) / 1000;

    function getCountFromSlider(val) { return Math.floor(Math.exp(minVal + scale * val)); }
    function getSliderFromCount(count) { if(count < 1) count = 1; return (Math.log(count) - minVal) / scale; }

    function updateState(count, source) {
        if(count < 1) count = 1; if(count > 2000000) count = 2000000;
        const liters = count * 120;
        txtBins.innerText = `${count.toLocaleString()} ${count === 1 ? 'bin' : 'bins'}`;
        txtLiters.innerText = `(${liters.toLocaleString()} L/s)`;
        if(source !== 'input') input.value = liters;
        if(source !== 'slider') slider.value = getSliderFromCount(count);
        
        populateScene(count, source !== 'init');
    }

    slider.addEventListener('input', (e) => { updateState(getCountFromSlider(parseInt(e.target.value)), 'slider'); });
    input.addEventListener('change', (e) => { const val = parseInt(e.target.value); if(!val) return; updateState(Math.ceil(val / 120), 'input'); });

    updateState(10, 'init');

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0.5, 0);

    controls.addEventListener('start', () => {
        shouldAutoPan = false;
    });
    
    function animate() {
        requestAnimationFrame(animate);

        if (shouldAutoPan) {
            camera.position.lerp(targetCameraPos, 0.05);
            controls.target.lerp(targetLookAt, 0.05);
            
            if(camera.position.distanceTo(targetCameraPos) < 0.5) {
                shouldAutoPan = false;
            }
        }

        controls.update();

        const dist = camera.position.distanceTo(controls.target);
        scene.fog.near = dist * 0.5;
        scene.fog.far = dist * 5.0;

        if(isHighPoly && imBody && instanceData.length > 0) {
             const t = Date.now() * 0.005;
             for(let i = 0; i < instanceData.length; i++) {
                 const data = instanceData[i];
                 const wobbleZ = Math.sin(t + data.phase) * 0.03;

                 dummy.position.set(data.x, data.y, data.z);
                 dummy.rotation.set(0, data.rotY, wobbleZ);
                 dummy.updateMatrix();
                 imBody.setMatrixAt(i, dummy.matrix);
                 imLid.setMatrixAt(i, dummy.matrix);

                 dummy.rotation.set(0, data.rotY, wobbleZ); 
                 dummy.position.set(data.x - 0.32, data.y + 0.1, data.z - 0.25);
                 dummy.updateMatrix();
                 imWheelLeft.setMatrixAt(i, dummy.matrix);

                 dummy.position.set(data.x + 0.32, data.y + 0.1, data.z - 0.25);
                 dummy.updateMatrix();
                 imWheelRight.setMatrixAt(i, dummy.matrix);
             }
             imBody.instanceMatrix.needsUpdate = true;
             imLid.instanceMatrix.needsUpdate = true;
             imWheelLeft.instanceMatrix.needsUpdate = true;
             imWheelRight.instanceMatrix.needsUpdate = true;
        }

        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>
